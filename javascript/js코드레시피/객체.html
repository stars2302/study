<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /* ----------------------- 객체 -------------------------- */

    //객체 구조
    const object = {
      id: 1,
      name: '세모',
      age: 4
    }

    // - 속성(property) = "id:1" "name:'세모'" "age: 4"
    // - 키(key) = "id" "name" "age"
    // - 값(value) = "1" "'세모'" "4"

    // 객체 특징
    // - 속성의 데이터 타입의 제한은 없다. (배열,객체,함수 상관없이 모두 사용가능)
    /* -------------------------------------------------------- */


    /* ----------- 객체 선언, 수정, 확인 -------------------- */

    // 1. 객체 선언하기
    // 1-1. 빈 객체 만들기
    let object2 = {};

    // 1-2. 객체 선언하기
    const object3 = {
      name: '승관',
      age: '26'
    }


    // 2. 객체 정보 수정하기
    // 2-1. 빈객체에 정보 채워넣기(const 변수일 경우X)
    object2 = {name:'벼리', age: 7}

    // 2-2. 해당 객체의 '값' 바꾸기
    object.age = 3;
    object['name'] = '줄리'


    // 3. 객체 정보 확인하기
    console.log(object.age); //3
    console.log(object['name']); //줄리

    // 3-1. 없는 key를 불러올 경우, undefined
    console.log(object.address);//undefined


    // 4. 다차원 객체 생성, 수정, 확인
    // 4-1. 생성
    let object4 = {
      result : true,
      list : [
        {id: 1, name:'jelly', age: 17, address: '경기도'},
        {id: 2, name:'kelly', age: 20, address: '서울'}
      ],
      method1 : ()=>{
        console.log('함수실행');
      },
      method2 : ()=>{
        console.log('승관이 귀여운 함수 실행');
      }
    }

    // 4-2. 수정
    object4.result = false;
    object4.list[1].name = 'sally';

    // 4-3. 확인 및 함수실행
    console.log(object4.result);//false
    console.log(object4.list[1].name); //sally
    console.log(object4.list[0].name); //jelly

    object4.method2(); //승관이 귀여운 함수 실행
    /* -------------------------------------------------------- */


    /* --------------- 객체 복사하기(얕은..) -------------------- */

    // 1. {...복사객체}
    const object5 = {
      name: '부승관',
      position: '한국 보컬 탑',
      special: '랫서팬더 닮은 외모',
      arr : [1,2,3,4,5],
      age: 14
    }

    const copyObj = {...object5};
    console.log(copyObj); //{name: '부승관', position: '한국 보컬 탑', special: '랫서팬더 닮은 외모' ,arr: [1,2,3,4,5]}

    // 2. Object.assign({}, 복사객체);
    const copyObj2 = Object.assign({},object5);
    console.log(copyObj2); //{name: '부승관', position: '한국 보컬 탑', special: '랫서팬더 닮은 외모' ,arr: [1,2,3,4,5]}


    // ** 주의 : 원본 데이터가 바뀔 시 복사데이터도 함께 바뀜. 그래서 얕은복사..
    // 배열의 데이터만 함께 바뀜...?
    object5.special = '귀여움 한도초과';
    object5.arr[0] = 100;
    object5.age = 20;
    console.log(object5);//{name: '부승관', position: '한국 보컬 탑', special: '귀여움 한도초과' ,arr: [100,2,3,4,5], age: 20;}
    console.log(copyObj);//{name: '부승관', position: '한국 보컬 탑', special: '랫서팬더 닮은 외모' ,arr: [100,2,3,4,5], age: 14}
    console.log(copyObj2);//{name: '부승관', position: '한국 보컬 탑', special: '랫서팬더 닮은 외모' ,arr: [100,2,3,4,5], age: 14}
    /* -------------------------------------------------------- */


    /* --------------- 객체 데이터 key 유무확인 -------------------- */

    // 1. 객체.hasOwnProperty(key);
    const object6 = {
      name: '세모',
      age: 4
    }
    console.log(object6.hasOwnProperty('address')); //false
    console.log(object6.hasOwnProperty('name')); //true

    // 1-1. 값(value)는 확인 불가능.
    console.log(object6.hasOwnProperty('세모')); //false
    
    
    // 2. key in 객체
    console.log('name' in object6); //true
    console.log('address' in object6); //false

    // 2-1. 마찬가지로 값(value) X
    console.log('세모' in object6); //false


    // 3. 값(value)이 비어있지 않은지 확인
    console.log(object6.name != null); //true
    console.log(object6.name.includes('세')); //true
    /* -------------------------------------------------------- */


    /* ---------------- 객체 구성 확인 ---------------------- */
    const object10 = {
      name: 'semo',
      age: 4,
      address: 'america'
    }

    // 1. Object.keys(대상객체);
    // 대상객체의 key를 배열형태로 반환.
    console.log(Object.keys(object10)); //['name','age','address']

    // 2. Object.values(대상객체);
    // 대상객체의 value를 배열형태로 반환.
    console.log(Object.values(object10)); //['semo', 4, 'america']

    // 3. Object.entries(대상객체);
    // 대상객체의 key,value를 2차배열로 반환
    console.log(Object.entries(object10)); //[ ['name','semo'], ['age', 4], ['address','america'] ]
    /* -------------------------------------------------------- */


    /* ---------------- 객체 분할대입(비구조화 할당) ---------------------- */

    // 1. 기본구조
    // 객체의 key와 같은 변수를 만들어 각각의 value를 저장.
    const object11 = {
      key1 : 'value1',
      key2 : 'value2',
      key3 : 'value3'
    }

    const { key0, key2, key3 } = object11; 
    //* 주의! : 변수 이름은 무조건 객체의 key와 일치해야됨!!
    // key 순서는 상관없음
    /*
    const key0 = object11.key0;
    const key2 = object11.key2;
    const key3 = object11.key3;
    와 같은 것임.
    */

    console.log(key0); //undefined
    console.log(key2); //value2
    console.log(key3); //value3


    // 2. 내가 원하는 이름으로 변수만들기(주의점을 개선하기 위한 방법!)
    const object12 = {
      name: '벼리',
      age: 8
    }

    const {name:starName} = object12;
    // key이름 대신 starName을 변수이름으로 지정.

    console.log(starName); //벼리
    console.log(name); // (빈값)
    /* -------------------------------------------------------- */

  </script>
</body>
</html>